# Правила оформления кода

Данные правила были приняты или путем обсуждения, или голосования, и должны соблюдаться всей командой и по возможности автоматизироваться линтером (как вариант - ESLint'ом) или средствами иных статичных анализаторов.

... обговорить и описать правила

# Шаблоны и стандартные подходы к реализации

## Компонентная база

- gar-button - кнопка
- gar-icon - иконками
- gar-carousel - карусель
- gar-img-uploader - загрузчик файлов
- ... заполняется

## Генерация SVG-спрайта и публикация иконок

Для публикации иконок используется компонент GarIconComponent, который принимает на вход имя иконки:
``` html
<gar-icon name="avatar_1"></gar-icon>
```

Для генерации спрайта с иконками необходимо поместить новые иконки в папку src/assets/icons-source, 
для корректного отображения необходимо почистить в коде файла атрибуты fill 
(в противном случае не гарантируется применение аналогичных установленных параметров в файле стилей)
и выполнить команду в терминале (при нахождении в папке src/assets) 
``` 
svg2sprite icons-source icons/main-sprite.svg
```

## Постоянные подписки

Не рекомендуется использовать контейнер подписок

``` ts
❌ subscriptions: any = {};
❌ private _subscriptions: { [key: string]: Subscription } = {};
```

Не рекомендуется использовать именованные подписки, так как при многократном вызове метода в котором осуществляется подписка, ссылка будет заменяться новой, а старая оставаться не обрабатываемой. Что приводит к усложнению и необходимости дополнительно контролировать вызовы и выполнение методов содержащих присвоение подписок.

``` ts
❌ this._subscriptions.submit = this.http.post<...>(...).subscribe(...);
```

Не рекомендуется использовать именованные подписки для контроля состояния выполнения

``` ts
❌ if (!this._subscriptions.submitting) {
		this._subscriptions.submitting = this.http.post<...>(...).subscribe(() => {
			delete this._subscriptions.submitting;
		});
	} else {
		...
	}
```

Не рекомендуется использовать контейнеры подписок, для избежания добавления однотипного кода реализующего логику ручной отписки.

``` ts
❌ ngOnDestroy() {
		Object.values(this._subscriptions).map((subscription) => subscription.unsubscribe());
	}
```

Рекомендуется использовать объект состояния жизни компонента!

``` ts
@Component({
    selector: 'app-example',
    templateUrl: './template.html',
    providers: [
		DestroyService <-- При создании экземпляра компонента резолвится новый экземпляр сервиса а при ngOnDestroy компонента у всех полученный провайдеров вызывается тоже освобождение
	]
})
export class GarDestroyExample {
    constructor(
		private _destroy$: DestroyService,
		private _http: HttpClient) {
        this._http.get<...>(...).pipe(
			takeUntil(this._destroy$) <-- при OnDestroy компонента вызовется дестрой провайдера, тот вызовет next у _destroy$ и выполниться завершение подписки если она еще не отписалась сама (закпомплитилась) ...
		).subscribe(() => {
			console.log('...');
		});
    }
}
```
